<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>acgmake: Usage</title>
<link href="acg_style.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.8 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1><a class="anchor" name="usage">Usage</a></h1>When invoked, <code>acgmake</code> recursively traverses a whole subtree of dirctories, starting at the current one. Each directory containing an <code>ACGMakefile</code> will be processed.<p>
<code>acgmake</code> assumes that the current directory is part of a larger source code tree and tries to find the top-level directory of that project by going up the hierarchy until a file <code>ACGMakefile.proj</code> is found. If this file is found it will be included, so you can place additional project-specific configuration there. Additionally the include and library paths is extended by the parent directory of the project directory. E.g. if you have a directory structure like this<p>
<div class="fragment"><pre>projects/
|-- proj_1
|   |-- ACGMakefile
|   |-- ACGMakefile.proj
|   |-- code
....
|-- proj_2
|   |-- ACGMakefile
|   |-- ACGMakefile.proj
|   |-- code
...
</pre></div><p>
and you call <code>acgmake</code> from the <code>projects/proj_1/code/</code> directory, <code>acgmake</code> will find <code>projects/proj_1/</code> as the project top-level directory and add <code>projects/</code> to your include and lib paths. This means you can include files like<p>
<div class="fragment"><pre><span class="preprocessor">#include &lt;proj_1/some_dir/some_file.hh&gt;</span>
<span class="preprocessor">#include &lt;proj_2/some_other_dir/some_other_file.hh&gt;</span>
</pre></div><p>
and use code/libs from other directories like explained below.<p>
<dl compact><dt><b>Attention:</b></dt><dd>This nice functionality requires that you place a (possibly empty) file named <code>ACGMakefile.proj</code> in the top-level directory of your projects.</dd></dl>
The make-files named <code>ACGMakefile</code> control what to do for these directories (e.g. what modules to apply, see <a class="el" href="modules.html">List of Modules</a>), the command line options tell <code>acgmake</code> how to do it. E.g., the module <code>cxx</code> used for <code>C++</code> code generation will build a library from all the <code>*</code>.cc files for each directory, files containing a <code>main()</code> function will be detected, compiled, and linked to applications.<p>
<br>
<br>
<p>
Usually you call <code>acgmake</code> with a list of <em>options</em> and a list of <em>targets</em>. The options controll the code compilation process as well as the linking behaviour. The targets tell <code>acgmake</code> what to do, the options tell how to do it.<p>
The options controlling the <code>C</code> / <code>C++</code> code compilation are: <ul>
<li><code>-dbg</code>: Compile w/o optimization and generate debug information (default). </li>
<li><code>-prf</code>: Compile w/o optimization and generate profiling information. </li>
<li><code>-opt</code>: Turn off debugging, turn on optimization. </li>
<li><code>-max</code>: Use maximum available optimization. </li>
<li><code>-comp=</code> </li>
</ul>
<p>
: Use a specific compiler. Causes the file <code>/ACG/acgdev/acgmake/configs/config</code>. to be included. You can specify compiler specific settings there.<p>
The type of library/executable generation can be set by: <ul>
<li><code>-shared</code>: Build and use a <em>shared</em> library for each processed directory (default). </li>
<li><code>-static</code>: Build and use a <em>static</em> library for each processed directory. The system libs will still be linked shared. </li>
<li><code>-allstatic</code>: Like <code>-static</code>, but now system libs are also linked statically, i.e. a completely static bindary is build.</li>
</ul>
Output options: <ul>
<li><code>-debug</code>: Since version 1.1, acgmake hides the command lines it triggers. You can show these lines using the <code>debug</code> option.</li>
</ul>
Other options: <ul>
<li><code>-j</code>: This will cause make to run several compilation jobs at once. </li>
<li><code>-j</code> </li>
</ul>
<p>
: This will cause make to run &lt;n&gt; compilation jobs at once. <ul>
<li><code>-dist</code>: Distributed compiling using distcc, implies <code>-j</code>. </li>
<li><code>-relink</code>: Forces the relinking of executables, even if dependencies will not require it. This is usefull when linking static libraries, since they are not dealt with by dependencies.</li>
</ul>
Supported targets are: <ul>
<li><code>build:</code> Recursively do the work for all directories containing an <code>ACGMakefile</code>. </li>
<li><code>local-build</code>: Same as <code>build</code>, but only for the current directory. </li>
<li><code>clean:</code> Recursively clean up everything created by <code>acgmake</code>. </li>
<li><code>local-clean</code>: Same as above, only for the current directory. </li>
<li><code>sysinfo:</code> Print some system information.</li>
</ul>
<br>
<br>
<p>
In each directory tp be processed <code>acgmake</code> will look for a file named <code>ACGMakefile</code>. The syntax will be plain GNU make syntax. A typical makefile looks like this.<p>
<div class="fragment"><pre><span class="preprocessor">#==  SYSTEM PART -- DON'T TOUCH  ==============================================</span>
<span class="preprocessor"></span>include $(ACGMAKE)/Config
<span class="preprocessor">#==============================================================================</span>
<span class="preprocessor"></span>

SUBDIRS = $(call find-subdirs)

PACKAGES := qt glut opengl x11 math

PROJ_LIBS = OpenMesh ACG/Scenegraph

MODULES := uic moc cxx


<span class="preprocessor">#==  SYSTEM PART -- DON'T TOUCH  ==============================================</span>
<span class="preprocessor"></span>include $(ACGMAKE)/Rules
<span class="preprocessor">#==============================================================================</span>
</pre></div><p>
As you see you have to specify only four parameters:<p>
<ul>
<li><code>SUBDIRS</code> specifies in what sub-directories to proceed. May be a space-separated list of directories or (the default) value <code>$(call find-subdirs)</code>. This function call returns all sub-directories containing a <code>Makefile</code>.</li>
</ul>
<ul>
<li><code>PACKAGES</code> tells <code>acgmake</code> what 3rd party libraries you want to use for compiling the current directory. In the above example we need OpenGL, the GL utility library <code>glut</code>, Trolltech's Qt and some functions from the math library.</li>
</ul>
<ul>
<li><code>PROJ_LIBS:</code> As <code>acgmake</code> recursively traverses your source tree it creates a (shared or static) library for each directory. You can use these libraries in the current directory by naming the corresponding directories (relative to the top-level directory). In the example we want to use the <code>OpenMesh</code> library and the <code>Scenegraph</code> library of the ACG project.</li>
</ul>
<ul>
<li><code>MODULES:</code> This space-separated list specifies what modules to use for the actual compilation. These modules will be applied in the order they are given. In the example the Qt tool <code>uic</code> generates C++ header and implementation files from Qt designer files first, the Qt preprocessor <code>moc</code> is applied in the second step. After that the <code>cxx</code> modules does the C++ compilation.</li>
</ul>
<dl compact><dt><b>Attention:</b></dt><dd>For the variables PACKAGES, PROJ_LIBS and MODULES the order is important. While the order in wich modules are to apply is quite obvious, a wring order of packages and libraries can lead to undefined symbols during linking. If one package/library depends on one another, the other should be given later in the string, like "glut opengl" instead of "opengl glut". This may only lead to errors when you compile static libs using the <code>-static</code> command line option.</dd></dl>
In addition any internal (module specific) variables can be overridden. For example if you have specific options for a certain compiler or operating system, you could do something like this:<p>
<div class="fragment"><pre>ifeq ($(CXX_COMP),g++)
  CXX_DEFS += -ftemplate-depth-100
endif 

ifeq ($(OS),Linux)
  Some Linux specific stuff
endif
</pre></div><hr>
<address>
<small>
<a href="http://www.rwth-graphics.de">
<img src="acg_icon.gif" alt="acg pic" align="middle" border=0>
</a>
Project <b>acgmake</b>, 
&copy;&nbsp; Computer Graphics Group, RWTH Aachen.
Documentation generated using 
<a href="http://www.doxygen.org/index.html">
<b>doxygen</b>
</a>.
</small>
</address>
</body>
</html>
